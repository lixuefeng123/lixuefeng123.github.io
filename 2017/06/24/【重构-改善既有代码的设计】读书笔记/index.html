<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="重构," />





  <link rel="alternate" href="/atom.xml" title="Li Xuefeng's Blog" type="application/atom+xml" />






<meta name="description" content="重构：在代码写好之后改进它的设计。任何一个傻瓜都能写出计算机可以理解的代码。唯有写出人类容易理解的代码，才是优秀的程序员。
重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。
重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。
因为重点阅读了7-9章，这里将7-9张章的读书笔记总结如下：在对象之间搬移特性在对象">
<meta property="og:type" content="article">
<meta property="og:title" content="【重构 改善既有代码的设计】读书笔记">
<meta property="og:url" content="http://yoursite.com/2017/06/24/【重构-改善既有代码的设计】读书笔记/index.html">
<meta property="og:site_name" content="Li Xuefeng's Blog">
<meta property="og:description" content="重构：在代码写好之后改进它的设计。任何一个傻瓜都能写出计算机可以理解的代码。唯有写出人类容易理解的代码，才是优秀的程序员。
重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。
重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。
因为重点阅读了7-9章，这里将7-9张章的读书笔记总结如下：在对象之间搬移特性在对象">
<meta property="og:updated_time" content="2018-11-13T12:05:42.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【重构 改善既有代码的设计】读书笔记">
<meta name="twitter:description" content="重构：在代码写好之后改进它的设计。任何一个傻瓜都能写出计算机可以理解的代码。唯有写出人类容易理解的代码，才是优秀的程序员。
重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。
重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。
因为重点阅读了7-9章，这里将7-9张章的读书笔记总结如下：在对象之间搬移特性在对象">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/06/24/【重构-改善既有代码的设计】读书笔记/"/>





  <title>【重构 改善既有代码的设计】读书笔记 | Li Xuefeng's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Li Xuefeng's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">To be or not! Try your best!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/24/【重构-改善既有代码的设计】读书笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Li Xuefeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/author.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Li Xuefeng's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">【重构 改善既有代码的设计】读书笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-24T10:59:59+08:00">
                2017-06-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/程序设计/" itemprop="url" rel="index">
                    <span itemprop="name">程序设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/06/24/【重构-改善既有代码的设计】读书笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/06/24/【重构-改善既有代码的设计】读书笔记/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="重构：在代码写好之后改进它的设计。"><a href="#重构：在代码写好之后改进它的设计。" class="headerlink" title="重构：在代码写好之后改进它的设计。"></a>重构：在代码写好之后改进它的设计。</h3><p>任何一个傻瓜都能写出计算机可以理解的代码。唯有写出人类容易理解的代码，才是优秀的程序员。</p>
<p>重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。</p>
<p>重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。</p>
<h3 id="因为重点阅读了7-9章，这里将7-9张章的读书笔记总结如下："><a href="#因为重点阅读了7-9章，这里将7-9张章的读书笔记总结如下：" class="headerlink" title="因为重点阅读了7-9章，这里将7-9张章的读书笔记总结如下："></a>因为重点阅读了7-9章，这里将7-9张章的读书笔记总结如下：</h3><h4 id="在对象之间搬移特性"><a href="#在对象之间搬移特性" class="headerlink" title="在对象之间搬移特性"></a>在对象之间搬移特性</h4><p>在对象的设计过程中，『决定把责任放在哪儿』即使不是最重要的事，也是最重要的事之一。</p>
<h4 id="搬移函数-Move-Method"><a href="#搬移函数-Move-Method" class="headerlink" title="搬移函数 Move Method"></a>搬移函数 Move Method</h4><p>你的程序中，有个函数与其所在类之外的另一个类进行更多交流：调用后者，或被后者调用 -&gt; 在该函数最常引用的类中建立一个有类似行为的新函数。将旧函数变成一个单纯的委托函数，或是将旧函数完全移除</p>
<ul>
<li>检查源类中被源函数所使用的一切特性（包括字段和函数），考虑它们是否也该被搬迁（如果某个特性只被你打算搬移的那个函数用到，就应该将它一并搬迁。如果另有其他函数使用了这个特性，你可以考虑将使用该特性的所有函数全都一并搬迁。有时候，搬移一组函数比逐一搬移简单些）</li>
<li>检查源类的子类和超类，看看是否有该函数的其他声明（如果出现其他声明，你或许无法进行搬移，除非目标类也同样表现出多态性）</li>
<li>在目标类中声明这个函数（你可以选择一个更有意义的名称）</li>
<li>将源函数的代码复制到目标函数中。调整后者，使其能在新类中正常运行（如果源函数包含异常处理，你得判断逻辑上应该由哪个类来处理这一异常。如果应该由源类来负责，就把异常处理留在原地）</li>
<li>编译目标类</li>
<li>决定如何从源函数正确引用目标对象</li>
<li>修改源函数，使之成为一个纯委托函数</li>
<li>编译，测试</li>
<li>决定是否删除源函数，或将它当作一个委托函数保留下来（如果你经常要在源对象中引用目标函数，那么将源函数作为委托函数保留下来会比较简单）</li>
<li>如果要移除源函数，请将源类中对源函数的所有调用，替换为对目标函数的调用</li>
<li>编译，测试</li>
</ul>
<h4 id="搬移字段-Move-Field"><a href="#搬移字段-Move-Field" class="headerlink" title="搬移字段 Move Field"></a>搬移字段 Move Field</h4><p>你的程序中，某个字段被其所在类之外的另一个类更多的用到 -&gt; 在目标类新建一个字段，修改源字段的所有用户，令它们改用新字段</p>
<ul>
<li>如果字段的访问级是 public，使用 Encapsulate Field 将它封装起来（如果你有可能移动那些频繁访问该字段的函数，或如果有许多函数访问某个字段，先使用 Self Encapsulate Field 也许会有帮助）</li>
<li>编译，测试</li>
<li>在目标类中建立与源字段相v同的字段，并同时建立相应的设值/取值函数</li>
<li>编译目标类</li>
<li>决定如何在源对象中引用目标对象（首先看是否有一个现成的字段或函数可以帮助你得到目标对象，如果没有，就看能否轻易建立这样一个函数。如果还不行，就得在源类中新建一个字段来存放目标对象。这可能是个永久性修改，但你也可以让它是暂时的，因为后续重构可能会把这个新建字段除掉）</li>
<li>删除源字段</li>
<li>将所有对源字段的引用替换为对某个目标函数的调用</li>
<li>编译，测试</li>
</ul>
<h4 id="提炼类-Extract-Class"><a href="#提炼类-Extract-Class" class="headerlink" title="提炼类 Extract Class"></a>提炼类 Extract Class</h4><p>某个类做了应该由两个类做的事 -&gt; 建立一个新类，将相关的字段和函数从旧类搬移到新类</p>
<ul>
<li>决定如何分解类所负的责任</li>
<li>建立一个新类，用以表现从旧类中分离出来的责任（如果旧类剩下的责任与旧类名称不符，为旧类更名）</li>
<li>建立『从旧类访问新类』的连接关系（有可能需要一个双向链接。但是在真正需要它之前，不要建立『从新类通往旧类』的链接）</li>
<li>对于你想搬移的每一个字段，运用 Move Field 搬移之</li>
<li>每次搬移后，编译、测试</li>
<li>使用 Move Method 将必要函数搬移到新类，先搬移低层函数（也就是『被其他函数调用』多于『调用其他函数』的函数），再搬移较高层函数</li>
<li>每次搬移之后，编译、测试</li>
<li>检查，精简每个类的接口（如果你建立其双向链接，检查是否可以将它改为单向连接）</li>
<li>决定是否公开新类。如果你的确需要公开它，就要决定让它成为引用对象还是不可变的值对象</li>
</ul>
<p>这里也存在危险性。如果需要确保两个对象同时被锁定，你就面临事务问题，需要使用其他类型的共享锁。</p>
<h4 id="将类内联化-Inline-Class"><a href="#将类内联化-Inline-Class" class="headerlink" title="将类内联化 Inline Class"></a>将类内联化 Inline Class</h4><p>某个类没有做太多事情 -&gt; 将这个类的所有特性搬移到另一个类中，然后移除原类</p>
<ul>
<li>在目标类身上声明源类的 public 协议，并将其中所有函数委托至源类（如果『以一个独立接口表示源类函数』更合适的话，就应该在内联之前先使用 Extract Interface）</li>
<li>修改所有源类引用点，改而引用目标类（将源类声明为 private，以斩断包之外的所有引用可能。同时修改源类的名称，这便可使编译器帮助你捕捉到所有对于源类的隐藏引用点）</li>
<li>编译，测试</li>
<li>运用 Move Method 和 Move Field，将源类的特性全部搬移到目标类</li>
<li>为源类举行一个简单的『丧礼』。</li>
</ul>
<h4 id="隐藏委托关系-Hide-Delegate"><a href="#隐藏委托关系-Hide-Delegate" class="headerlink" title="隐藏委托关系 Hide Delegate"></a>隐藏委托关系 Hide Delegate</h4><p>客户通过一个委托类来调用另一个对象 -&gt; 在服务类上建立客户所需的所有函数，用以隐藏委托关系</p>
<ul>
<li>对于每一个委托关系中的函数，在服务对象端建立一个简单的委托函数</li>
<li>调整客户，令它只调用服务对象提供的函数（如果使用者和服务提供者不在同一个包）</li>
<li>每次调整后，编译并测试</li>
<li>如果将来不再有任何客户需要用到 Delegate，便课移除服务对象中的相关访问函数</li>
<li>编译，测试</li>
</ul>
<h4 id="移除中间人-Remove-Middle-Man"><a href="#移除中间人-Remove-Middle-Man" class="headerlink" title="移除中间人 Remove Middle Man"></a>移除中间人 Remove Middle Man</h4><p>某个类做了过多的简单委托动作 -&gt; 让客户直接调用受托类</p>
<ul>
<li>建立一个函数，用以获得受托对象</li>
<li>对于每个委托函数，在服务类中删除该函数，并让需要调用该函数的客户转为调用受托对象</li>
<li>处理每个委托函数后，编译、测试</li>
</ul>
<h4 id="引入外加函数-Introduce-Foreign-Method"><a href="#引入外加函数-Introduce-Foreign-Method" class="headerlink" title="引入外加函数 Introduce Foreign Method"></a>引入外加函数 Introduce Foreign Method</h4><p>你需要为提供服务的类增加一个函数，但你无法修改这个类 -&gt; 在客户类中建立一个函数，并以第一参数形式传入一个服务类实例，外加函数终究是权宜之计。如果有可能，你仍然应该将这些函数搬移到它们的理想家园。如果由于代码所有权的原因使你无法这么做，就把外加函数交给服务类的拥有者，请他帮你在服务类中实现这个函数。</p>
<ul>
<li>在客户类中建立一个函数，用来提供你需要的功能（这个函数不应该调用客户类的任何特性。如果它需要一个值，把该值当做参数传给它）</li>
<li>以服务类实例作为该函数的第一个参数</li>
<li>将该函数注释为『外加函数(foreign method)，应该在服务类实现』（这么一来，如果将来有机会将外加函数搬移到服务类中时，你便可以轻松找出这些外加函数）</li>
</ul>
<h4 id="引入本地扩展-Introduce-Local-Extension"><a href="#引入本地扩展-Introduce-Local-Extension" class="headerlink" title="引入本地扩展 Introduce Local Extension"></a>引入本地扩展 Introduce Local Extension</h4><p>你需要为服务类提供一些额外函数，但你无法修改这个类 -&gt; 建立一个新类，使它包含这些额外函数。让这个扩展品陈伟源类的子类或包装类</p>
<ul>
<li>建立一个扩展类，将它作为原始类的子类或包装类</li>
<li>在扩展类中加入转型构造函数（所谓『转型构造函数』是指『接受原对象作为参数』的构造函数。如果采用子类化方案，那么转型构造函数应该调用适当的超类构造函数；如果采用包装类方案，那么转型构造函数应该将它得到的传入参数以实例变量的形式保存起来，用作接受委托的原对象）</li>
<li>在扩展类中加入新特性</li>
<li>根据需要，将原对象替换为扩展对象</li>
<li>将针对原始类定义的所有外加函数搬移到扩展类中</li>
</ul>
<h3 id="重新组织数据"><a href="#重新组织数据" class="headerlink" title="重新组织数据"></a>重新组织数据</h3><h4 id="自封装字段-Self-Encapsulate-Field"><a href="#自封装字段-Self-Encapsulate-Field" class="headerlink" title="自封装字段 Self Encapsulate Field"></a>自封装字段 Self Encapsulate Field</h4><p>你直接访问一个字段，但与字段之间的耦合关系逐渐变得笨拙 -&gt; 为这个字段建立取值/设值函数，并且只以这些函数来访问字段</p>
<ul>
<li>为待封装字段建立取值/设值函数</li>
<li>找出该字段的所有引用点，将它们全部改为调用取值/设值函数</li>
<li>将该字段声明为 private</li>
<li>复查，确保找出所有引用点</li>
<li>编译，测试</li>
</ul>
<h4 id="以对象取代数据值-Replace-Data-Value-with-Object"><a href="#以对象取代数据值-Replace-Data-Value-with-Object" class="headerlink" title="以对象取代数据值 Replace Data Value with Object"></a>以对象取代数据值 Replace Data Value with Object</h4><p>你有一个数据项 -&gt; 需要与其他数据和行为一起使用才有意义 -&gt; 将数据项变成对象</p>
<ul>
<li>为待替换数值新建一个类，在其中声明一个 final 字段，其类型和源类中的待替换数值类型一样。然后在新类中加入这个字段的取值函数，再加上一个接受此字段为参数的构造函数</li>
<li>编译</li>
<li>将源类中的待替换数值字段的类型改为前面新建的类</li>
<li>修改源类中该字段的取值函数，令它调用新类的取值函数</li>
<li>如果源类构造函数中用到这个待替换字段（多半是赋值动作），我们就修改构造函数，令它改用新类的构造函数来对字段进行赋值动作</li>
<li>修改源类中待替换字段的设值函数，令它为新类创建一个实例</li>
<li>编译，测试</li>
<li>现在，你有可能需要对新类使用 Change Value to Reference</li>
</ul>
<h4 id="将值对象改为引用对象-Change-Value-to-Reference"><a href="#将值对象改为引用对象-Change-Value-to-Reference" class="headerlink" title="将值对象改为引用对象 Change Value to Reference"></a>将值对象改为引用对象 Change Value to Reference</h4><p>你从一个类衍生出许多彼此相等的实例，希望将它们替换为同一个对象 -&gt; 将这个值对象编程引用对象</p>
<ul>
<li>使用 Replace Constructor with Factory Method</li>
<li>编译，测试</li>
<li>决定由什么对象负责提供访问新对象的途径（可能是一个静态字典或一个注册表对象；也可以使用多个对象作为新对象的访问点）</li>
<li>决定这些引用对象应该预先创建号，或是应该动态创建（如果这些引用对象是预先创建号的，而你必须从内存中将它们读取出来，那么就得去报它们在被需要的时候能够被及时加载）</li>
<li>修改工厂函数，令它返回引用对象（如果对象是预先创建号的，你就需要考虑：万一有人请求一个并不存在的对象，要如何处理错误；可能希望对工厂函数使用 Rename Method，使其传达这样的信息：它返回的是一个已存在的对象）</li>
<li>编译，测试</li>
</ul>
<h4 id="将引用对象改为值对象-Change-Reference-to-Value"><a href="#将引用对象改为值对象-Change-Reference-to-Value" class="headerlink" title="将引用对象改为值对象 Change Reference to Value"></a>将引用对象改为值对象 Change Reference to Value</h4><p>你有一个引用对象，很小且不可变，而且不易管理 -&gt; 将它变成一个值对象</p>
<ul>
<li>检查重构目标是否为不可变对象，或是否可修改为不可变对象（如果该对象目前还不是不可变的，就使用 Removing Setting Method，直到它成为不可变的为止；如果无法将该对象修改为不可变的，就放弃使用本项重构）</li>
<li>建立 equals() 和 hashCode()</li>
<li>编译，测试</li>
<li>考虑是否可以删除工厂函数，并将构造函数声明为 public</li>
</ul>
<h4 id="以对象取代数组-Replace-Array-with-Object"><a href="#以对象取代数组-Replace-Array-with-Object" class="headerlink" title="以对象取代数组 Replace Array with Object"></a>以对象取代数组 Replace Array with Object</h4><p>你有一个数组，其中的元素各自代表不同的东西 -&gt; 以对象替换数组。对于数组中的每个元素，以一个字段来表示</p>
<ul>
<li>新建一个类表示数组所拥有的信息，并在其中以一个 public 字段保存原先的数组</li>
<li>修改数组的所有用户，让它们改用新类的实例</li>
<li>编译，测试</li>
<li>逐一为数组元素添加取值/设值函数。根据元素的用途，为这些访问函数命名。修改客户代码，让它们动过访问函数取用数组内的元素。每次修改后，编译并测试</li>
<li>当所有对数组的直接访问都转而调用访问函数后，将新类中保存该数组的字段声明为 private</li>
<li>编译</li>
<li>对于数组内的每一个元素，在新类中创建一个类型相当的字段。修改该元素的访问函数，令它改用上述的新建字段</li>
<li>每修改一个元素，编译并测试</li>
<li>数组的所有元素都有了相应字段之后，删除该数组</li>
</ul>
<h4 id="复制『被监视的数据』-Duplicate-Observed-Data"><a href="#复制『被监视的数据』-Duplicate-Observed-Data" class="headerlink" title="复制『被监视的数据』 Duplicate Observed Data"></a>复制『被监视的数据』 Duplicate Observed Data</h4><p>你有一些领域数据置身于 GUI 控件中，而领域函数需要访问这些数据 -&gt; 将该数据复制到一个领域对象中。建立一个 Observer 模式，用以同步领域对象和 GUI 对象内的重复数据</p>
<ul>
<li>修改展现类，使其成为领域类的 Observer[GOF]（如果尚未有领域类，就建立一个；如果没有『从展现类到领域类』的关联，就将领域类保存与展现类的一个字段中）</li>
<li>针对 GUI 类中的领域数据，使用 Self Encapsulate Field</li>
<li>编译，测试</li>
<li>在事件处理函数中调用设值函数，直接更新 GUI 组件</li>
<li>编译，测试</li>
<li>在领域类中定义数据及其相关访问函数（确保领域类中的设值函数能够触发 Observer 模式的通报机制；对于被观察的数据，在领域类中使用与展现类所用的相同类型来保存。后续重构中你可以自由改变这个数据类型）</li>
<li>修改展现类中的访问函数，将它们的操作对象改为领域对象（而非 GUI 组件）</li>
<li>修改 Observer 的 update()，使其从相应的领域对象中将所需数据复制给 GUI 组件</li>
<li>编译，测试</li>
</ul>
<h4 id="将单向关联改为双向关联-Change-Unidirectional-Association-to-Bidirectional"><a href="#将单向关联改为双向关联-Change-Unidirectional-Association-to-Bidirectional" class="headerlink" title="将单向关联改为双向关联 Change Unidirectional Association to Bidirectional"></a>将单向关联改为双向关联 Change Unidirectional Association to Bidirectional</h4><p>两个类都需要使用对方特性，但期间只有一条单向连接 -&gt; 添加一个反向指针，并使修改函数能够同时更新两条连接</p>
<ul>
<li>在被引用类中增加一个字段，用以保存反向指针</li>
<li>决定由哪个类——引用端还是被引用端——控制关联关系</li>
<li>在被控端建立一个辅助函数，其命名应该清楚指出它的有限用途</li>
<li>如果既有的修改函数在控制端，让它负责更新方向指针</li>
<li>如果既有的修改函数在被控端，就在控制端建立一个控制函数，并让既有的修改函数调用这个新建的控制函数</li>
</ul>
<h4 id="将双向关联改为单向关联-Change-Bidirectional-Association-to-Unidirectional"><a href="#将双向关联改为单向关联-Change-Bidirectional-Association-to-Unidirectional" class="headerlink" title="将双向关联改为单向关联 Change Bidirectional Association to Unidirectional"></a>将双向关联改为单向关联 Change Bidirectional Association to Unidirectional</h4><p>两个类之间有双向关联，但其中一个类如今不再需要另一个类的特性 -&gt; 去除不必要的关联</p>
<p>双向关联很有用，但是也必须为它付出代价，那就是维护双向连接、确保对象被正确创建和删除增加的复杂度。而且，由于很多程序员并不习惯使用双向关联，它往往成为错误之源。大量的双向连接也很容易造成『僵尸对象』：某个对象本来已经该死亡了，却仍然保留在系统中，因为对它的引用还没有完全清除。</p>
<ul>
<li>找出保存『你想去除的指针』的字段，检查它的每一个用户，判断是否可以去除该指针（不但要检查直接访问点，也要检查调用这些直接访问点的函数）</li>
<li>如果客户使用了取值函数，先运用 Self Encapsulate Field 将待删除字段自我封装起来，然后使用 Substitute Algorithm 对付取值函数，令它不再使用该字段。然后编译、测试</li>
<li>如果客户并未使用取值函数，那就直接修改待删除字段的所有被引用点：改以其他途径获得该字段所保存的对象。每次修改后，编译并测试</li>
<li>如果已经没有任何函数使用待删除字段，移除所有对该字段的更新逻辑，然后移除该字段</li>
<li>编译，测试</li>
</ul>
<h4 id="以字面常量取代魔法数-Replace-Magic-Number-with-Symbolic-Constant"><a href="#以字面常量取代魔法数-Replace-Magic-Number-with-Symbolic-Constant" class="headerlink" title="以字面常量取代魔法数 Replace Magic Number with Symbolic Constant"></a>以字面常量取代魔法数 Replace Magic Number with Symbolic Constant</h4><p>你有一个字面数值，带有特别含义 -&gt; 创造一个常量，根据其意义为它命名，并将上述的字面数值替换为这个常量</p>
<ul>
<li>声明一个常量，令其值为原本的魔法数值</li>
<li>找出这个魔法数的所有引用点</li>
<li>检查是否可以使用这个新声明的常量来替换该魔法数。如果可以，便以此常量替换之</li>
<li>编译</li>
<li>所有魔法数都被替换完毕后，编译并测试。此时整个程序应该运转如常</li>
</ul>
<h4 id="封装字段-Encapsulate-Field"><a href="#封装字段-Encapsulate-Field" class="headerlink" title="封装字段 Encapsulate Field"></a>封装字段 Encapsulate Field</h4><ul>
<li>你的类中存在一个 public 字段 -&gt; 将它声明为 private，并提供相应的访问函数，为 Public 字段提供取值/设值函数</li>
<li>找到这个类以外使用该字段的所有地点。用取值/设置函数进行替代</li>
<li>每次修改之后，编译并测试</li>
<li>将字段的所有用户修改完毕后，把字段声明为 private</li>
<li>编译，测试</li>
</ul>
<h4 id="封装集合-Encapsulate-Collection"><a href="#封装集合-Encapsulate-Collection" class="headerlink" title="封装集合 Encapsulate Collection"></a>封装集合 Encapsulate Collection</h4><p>有个函数返回一个集合 -&gt; 让这个函数返回该集合的一个只读副本，并在这个类中提供添加/移除集合元素的函数（类似 MVC 的 M）</p>
<ul>
<li>加入为集合添加/移除元素的函数</li>
<li>将保存集合的字段初始化为一个空集合</li>
<li>编译</li>
<li>找出集合设值函数的所有调用者。你可以修改那个设值函数，让它使用上述新建立的『添加/移除元素』函数；也可以直接修改调用端，改让它们调用上述新建立的『添加/移除元素』函数</li>
<li>编译，测试</li>
<li>找出所有『通过取值函数获得集合并修改其内容』的函数。逐一修改这些函数，让它们改用添加/移除函数。每次修改后，编译并测试</li>
<li>修改完上述所有『通过取值函数获得集合并修改集合内容』的函数后，修改取值函数自身，使它返回该集合的一个只读副本</li>
<li>编译，测试</li>
<li>找出取值函数的所有用户，从中找出应该存在于集合所属对象内的代码。运用 Extract Method 和 Move Method 将这些代码移到宿主对象去</li>
<li>修改现有取值函数的名字，然后添加一个新取值函数，使其返回一个枚举。找出旧取值函数的所有被实用点，将它们都改为使用新取值函数</li>
<li>如果这一步跨度太大，可以先使用 Rename Method 修改原取值函数的名称；再建立一个新取值函数用以返回枚举；最后再修改所有调用者，使其调用新取值函数</li>
<li>编译，测试</li>
</ul>
<h4 id="以数据类取代记录-Replace-Record-with-Data-Class"><a href="#以数据类取代记录-Replace-Record-with-Data-Class" class="headerlink" title="以数据类取代记录 Replace Record with Data Class"></a>以数据类取代记录 Replace Record with Data Class</h4><p>你需要面对传统编程环境中的记录结构 -&gt; 为该记录创建一个『哑』数据对象</p>
<ul>
<li>新建一个类，表示这个记录</li>
<li>对于记录中的每一项数据，在新建的类中建立对应的一个 private 字段，并提供相应的取值/设值函数</li>
</ul>
<h4 id="以类取代类型码-Replace-Type-Code-with-Class"><a href="#以类取代类型码-Replace-Type-Code-with-Class" class="headerlink" title="以类取代类型码 Replace Type Code with Class"></a>以类取代类型码 Replace Type Code with Class</h4><ul>
<li>为类型码建立一个类</li>
<li>修改源类的实现，让它使用上述新建的类</li>
<li>编译，测试</li>
<li>对于源类中每一个使用类型码的函数，相应建立一个函数，让新函数使用新建的类</li>
<li>逐一修改源类用户，让它们使用新接口</li>
<li>每修改一个用户，编译并测试</li>
<li>删除使用类型码的旧接口，并删除保存旧类型码的静态变量</li>
<li>编译，测试</li>
</ul>
<h4 id="以子类取代类型码-Replace-Type-Code-with-Subclasses"><a href="#以子类取代类型码-Replace-Type-Code-with-Subclasses" class="headerlink" title="以子类取代类型码 Replace Type Code with Subclasses"></a>以子类取代类型码 Replace Type Code with Subclasses</h4><p>你有一个不可变的类型码，它会影响类的行为 -&gt; 以子类取代这个类型码</p>
<ul>
<li>使用 Self Encapsulate Field 将类型码自我封装起来（如果类型码被传递给构造函数，就需要将构造函数换成工厂函数）</li>
<li>为类型码的每一个数值建立一个相应的子类。在每个子类中覆写类型码的取值函数，使其返回相应的类型码值</li>
<li>每建立一个新的子类，编译并测试</li>
<li>从超类中删掉保存类型码的字段。将类型码访问函数声明为抽象函数</li>
<li>编译，测试</li>
</ul>
<h4 id="以-State-Strategy-取代类型码-Replace-Type-Code-with-State-Strategy"><a href="#以-State-Strategy-取代类型码-Replace-Type-Code-with-State-Strategy" class="headerlink" title="以 State/Strategy 取代类型码 Replace Type Code with State/Strategy"></a>以 State/Strategy 取代类型码 Replace Type Code with State/Strategy</h4><p>你有一个类型码，它会影响类的行为，但你无法通过继承手法消除它</p>
<ul>
<li>使用 Self Encapsulate Field 将类型码自我封装起来</li>
<li>新建一个类，根据类型码的用途为它命名。这就是一个状态对象</li>
<li>为这个新类添加子类，每个子类对应一种类型码</li>
<li>在超类中建立一个抽象的查询函数，用以返回类型码。在每个子类中覆写该函数，返回确切的类型码</li>
<li>编译</li>
<li>在源类中建立一个字段，用以保存新建的状态对象</li>
<li>调整源类中负责查询类型码的函数，将查询动作转发给状态对象</li>
<li>调整源类中为类型码设值的函数，将一个恰当的状态对象子类赋值给『保存状态对象』的那个字段</li>
<li>编译，测试</li>
</ul>
<h4 id="以字段取代子类-Replace-Subclass-with-Fields"><a href="#以字段取代子类-Replace-Subclass-with-Fields" class="headerlink" title="以字段取代子类 Replace Subclass with Fields"></a>以字段取代子类 Replace Subclass with Fields</h4><p>你的各个子类的唯一差别只在『返回常量数据』的函数身上 -&gt; 修改这些函数，使它们返回超类中的某个（新增）字段，然后销毁子类</p>
<ul>
<li>对所有子类使用 Replace Constructor with Factory Method</li>
<li>如果有任何代码直接引用子类，令它改而引用超类</li>
<li>针对每个常量函数，在超类中声明一个 final 字段</li>
<li>为超类声明一个 protected 构造函数，用以初始化这些新增字段</li>
<li>新建或修改子类构造函数，使他调用超类的新增构造函数</li>
<li>编译，测试</li>
<li>在超类中实现所有的常量函数，令它们返回相应字段值，然后将该函数从子类中删掉</li>
<li>每删除一个常量函数，编译并测试</li>
<li>子类中所有的常量函数都被删除后，使用 Inline Method 将子类构造函数内联到超类的工厂函数中</li>
<li>编译，测试</li>
<li>将子类删掉</li>
<li>编译，测试</li>
<li>重复『内联构造函数、删除子类』过程，直到所有子类都被删除</li>
</ul>
<h3 id="简化条件表达式"><a href="#简化条件表达式" class="headerlink" title="简化条件表达式"></a>简化条件表达式</h3><p>相比于面向过程程序，免息那个对象程序的条件表达式通常比较少，这是因为很多条件行为都被多态机制处理掉了。多态还有一种十分有用但鲜为人知的用途：通过 Introduce Null Object 去除对于 null 值的检验。</p>
<h4 id="分解条件表达式-Decompose-Conditional"><a href="#分解条件表达式-Decompose-Conditional" class="headerlink" title="分解条件表达式 Decompose Conditional"></a>分解条件表达式 Decompose Conditional</h4><p>你有一个复杂的条件(if-then-else)语句 -&gt; 从 if, then, else 三个段落中分别提炼出独立函数</p>
<ul>
<li>将 if 段落提炼出来，构成一个独立函数</li>
<li>将 then 段落和 else 段落都提炼出来，各自构成一个独立函数</li>
</ul>
<h4 id="合并条件表达式-Consolidate-Conditional-Expression"><a href="#合并条件表达式-Consolidate-Conditional-Expression" class="headerlink" title="合并条件表达式 Consolidate Conditional Expression"></a>合并条件表达式 Consolidate Conditional Expression</h4><p>你有一系列条件测试，都得到相同结果 -&gt; 将这些测试合并为一个条件表达式，并将这个条件表达式提炼成为一个独立函数</p>
<ul>
<li>确定这些条件语句都没有副作用（如果条件表达式有副作用，你就不能使用本项重构）</li>
<li>使用适当的逻辑操作符，将一系列相关条件表达式合并为一个</li>
<li>编译，测试</li>
<li>对合并后的表达式实施 Extract Method</li>
</ul>
<h4 id="合并重复的条件片段-Consolidate-Duplicate-Conditional-Fragments"><a href="#合并重复的条件片段-Consolidate-Duplicate-Conditional-Fragments" class="headerlink" title="合并重复的条件片段 Consolidate Duplicate Conditional Fragments"></a>合并重复的条件片段 Consolidate Duplicate Conditional Fragments</h4><p>在条件表达式的每个分支上有着相同的一段代码 -&gt; 将折断代码搬移到条件表达式之外</p>
<ul>
<li>鉴别出『执行方式不随条件变化而变化』的代码</li>
<li>如果这些共通代码位于条件表达式起始处，就将它移到条件表达式之前</li>
<li>如果这些共通代码位于条件表达式尾端，就将它移到条件表达式之后</li>
<li>如果这些共同代码位于条件表达式中段，就需要观察来向前或向后移动</li>
<li>如果共通代码不止一条语句，应该先使用 Extract Method 将共通代码提炼到一个独立函数中，再以前面所说的办法来处理</li>
</ul>
<h4 id="移除控制标记-Remove-Control-Flag"><a href="#移除控制标记-Remove-Control-Flag" class="headerlink" title="移除控制标记 Remove Control Flag"></a>移除控制标记 Remove Control Flag</h4><p>在一系列布尔表达式中，某个变量带有『控制标记(control flag)』的作用 -&gt; 以 break 语句或 return 语句取代控制标记</p>
<ul>
<li>找出让你跳出这段逻辑的控制标记值</li>
<li>找出对标记变量赋值的语句，代以恰当的 break 语句或 continue 语句</li>
<li>每次替换后，编译并测试</li>
<li><p>在未能提供 break 和 continue 语句的编程语言中，可以使用下述办法</p>
<ul>
<li>运用 Extract Method，将整段逻辑提炼到一个独立函数中</li>
<li>找出让你跳出这段逻辑的控制标记值</li>
<li>找出对标记变量赋值的语句，代以恰当的 return 语句</li>
<li>每次替换后，编译并测试</li>
</ul>
</li>
</ul>
<h4 id="以-Guard-语句取代嵌套条件表达式-Replace-Nested-Conditional-with-Guard-Clauses"><a href="#以-Guard-语句取代嵌套条件表达式-Replace-Nested-Conditional-with-Guard-Clauses" class="headerlink" title="以 Guard 语句取代嵌套条件表达式 Replace Nested Conditional with Guard Clauses"></a>以 Guard 语句取代嵌套条件表达式 Replace Nested Conditional with Guard Clauses</h4><p>函数中的条件逻辑使人难以看清正常的执行路径 -&gt; 使用 Guard 语句表现所有特殊情况</p>
<ul>
<li>对于每个检查，放进一个 Guard 语句（要么从函数中返回，要么抛出一个异常）</li>
<li>每次将条件检查替换成 Guard 语句后，编译并测试（如果所有 Guard 语句都导致相同结果，请使用 Consolidate Conditional Expressions）</li>
</ul>
<h4 id="以多态取代条件表达式-Replace-Conditional-with-Polymorphism"><a href="#以多态取代条件表达式-Replace-Conditional-with-Polymorphism" class="headerlink" title="以多态取代条件表达式 Replace Conditional with Polymorphism"></a>以多态取代条件表达式 Replace Conditional with Polymorphism</h4><p>你手上有个条件表达式，它根据对象类型的不同而选择不同的行为 -&gt; 将这个条件表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数</p>
<ul>
<li>如果要处理的表达式是一个更大函数中的一部分，首先对条件表达式进行分析，然后使用 Extract Method 将它提炼到一个独立函数去</li>
<li>如果有必要，使用 Move Method 将条件表达式放置到继承结构的顶端</li>
<li>任选一个子类，在其中建立一个函数，使之覆写超类中容纳条件表达式的那个函数。将与该子类相关的条件表达式分支复制到新建函数中，并对它进行适当调整</li>
<li>编译，测试</li>
<li>在超类中删掉条件表达式内被复制了的分支</li>
<li>编译，测试</li>
<li>针对条件表达式的每个分支，重复上述过程，直到所有分支都被移到子类内的函数为止</li>
<li>将超类之中容纳条件表达式的函数声明为抽象函数</li>
</ul>
<h4 id="引入-Null-对象"><a href="#引入-Null-对象" class="headerlink" title="引入 Null 对象"></a>引入 Null 对象</h4><p>你需要再三检查某对象是否为 null -&gt; 将 null 值替换为 null 对象</p>
<ul>
<li>为源类建立一个子类，使其行为就像是源类的 null 版本。在源类和 null 子类中都加上 isNull() 函数，前者的 isNull() 应该返回 false，后者的返回 true</li>
<li>编译</li>
<li>找出所有『请求源对象却获得一个 null』 的地方，修改这些地方，使它们改而获得一个空对象</li>
<li>找出所有『将源对象与 null 做比较的地方』，修改这些地方，使它们调用 isNull() 函数</li>
<li>编译，测试</li>
<li>找出这样的程序点：如果对象不是 null，做 A 动作，否则做 B 动作</li>
<li>对于每一个上述地点，在 null 类中覆写 A 动作，使其行为和 B 动作相同</li>
<li>使用上述被覆写的动作，然后删除『对象是否等于 null』 的条件测试。编译并测试</li>
</ul>
<h4 id="引入断言-Introduce-Assertion"><a href="#引入断言-Introduce-Assertion" class="headerlink" title="引入断言 Introduce Assertion"></a>引入断言 Introduce Assertion</h4><p>某一段代码需要对程序状态做出某种假设 -&gt; 以断言明确表现出这种假设</p>
<ul>
<li>如果你发现代码假设某个条件始终为真，就加入一个断言明确说明这种情况</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/重构/" rel="tag"># 重构</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/06/24/构建高性能Web站点读书笔记/" rel="next" title="【构建高性能Web站点】读书笔记">
                <i class="fa fa-chevron-left"></i> 【构建高性能Web站点】读书笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/06/24/jvm-类加载/" rel="prev" title="jvm 类加载">
                jvm 类加载 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div class="ds-thread" data-thread-key="2017/06/24/【重构-改善既有代码的设计】读书笔记/"
           data-title="【重构 改善既有代码的设计】读书笔记" data-url="http://yoursite.com/2017/06/24/【重构-改善既有代码的设计】读书笔记/">
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/author.png"
                alt="Li Xuefeng" />
            
              <p class="site-author-name" itemprop="name">Li Xuefeng</p>
              <p class="site-description motion-element" itemprop="description">多读书，多实践</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/lixuefeng123" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:lixuefeng228503@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://yq.aliyun.com/teams/23?spm=a2c4e.11153959.0.0.17ae186fwCdSN9" title="阿里推荐与搜索博客" target="_blank">阿里推荐与搜索博客</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#重构：在代码写好之后改进它的设计。"><span class="nav-number">1.</span> <span class="nav-text">重构：在代码写好之后改进它的设计。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#因为重点阅读了7-9章，这里将7-9张章的读书笔记总结如下："><span class="nav-number">2.</span> <span class="nav-text">因为重点阅读了7-9章，这里将7-9张章的读书笔记总结如下：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#在对象之间搬移特性"><span class="nav-number">2.1.</span> <span class="nav-text">在对象之间搬移特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#搬移函数-Move-Method"><span class="nav-number">2.2.</span> <span class="nav-text">搬移函数 Move Method</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#搬移字段-Move-Field"><span class="nav-number">2.3.</span> <span class="nav-text">搬移字段 Move Field</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#提炼类-Extract-Class"><span class="nav-number">2.4.</span> <span class="nav-text">提炼类 Extract Class</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#将类内联化-Inline-Class"><span class="nav-number">2.5.</span> <span class="nav-text">将类内联化 Inline Class</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#隐藏委托关系-Hide-Delegate"><span class="nav-number">2.6.</span> <span class="nav-text">隐藏委托关系 Hide Delegate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#移除中间人-Remove-Middle-Man"><span class="nav-number">2.7.</span> <span class="nav-text">移除中间人 Remove Middle Man</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#引入外加函数-Introduce-Foreign-Method"><span class="nav-number">2.8.</span> <span class="nav-text">引入外加函数 Introduce Foreign Method</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#引入本地扩展-Introduce-Local-Extension"><span class="nav-number">2.9.</span> <span class="nav-text">引入本地扩展 Introduce Local Extension</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重新组织数据"><span class="nav-number">3.</span> <span class="nav-text">重新组织数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#自封装字段-Self-Encapsulate-Field"><span class="nav-number">3.1.</span> <span class="nav-text">自封装字段 Self Encapsulate Field</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#以对象取代数据值-Replace-Data-Value-with-Object"><span class="nav-number">3.2.</span> <span class="nav-text">以对象取代数据值 Replace Data Value with Object</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#将值对象改为引用对象-Change-Value-to-Reference"><span class="nav-number">3.3.</span> <span class="nav-text">将值对象改为引用对象 Change Value to Reference</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#将引用对象改为值对象-Change-Reference-to-Value"><span class="nav-number">3.4.</span> <span class="nav-text">将引用对象改为值对象 Change Reference to Value</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#以对象取代数组-Replace-Array-with-Object"><span class="nav-number">3.5.</span> <span class="nav-text">以对象取代数组 Replace Array with Object</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复制『被监视的数据』-Duplicate-Observed-Data"><span class="nav-number">3.6.</span> <span class="nav-text">复制『被监视的数据』 Duplicate Observed Data</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#将单向关联改为双向关联-Change-Unidirectional-Association-to-Bidirectional"><span class="nav-number">3.7.</span> <span class="nav-text">将单向关联改为双向关联 Change Unidirectional Association to Bidirectional</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#将双向关联改为单向关联-Change-Bidirectional-Association-to-Unidirectional"><span class="nav-number">3.8.</span> <span class="nav-text">将双向关联改为单向关联 Change Bidirectional Association to Unidirectional</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#以字面常量取代魔法数-Replace-Magic-Number-with-Symbolic-Constant"><span class="nav-number">3.9.</span> <span class="nav-text">以字面常量取代魔法数 Replace Magic Number with Symbolic Constant</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#封装字段-Encapsulate-Field"><span class="nav-number">3.10.</span> <span class="nav-text">封装字段 Encapsulate Field</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#封装集合-Encapsulate-Collection"><span class="nav-number">3.11.</span> <span class="nav-text">封装集合 Encapsulate Collection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#以数据类取代记录-Replace-Record-with-Data-Class"><span class="nav-number">3.12.</span> <span class="nav-text">以数据类取代记录 Replace Record with Data Class</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#以类取代类型码-Replace-Type-Code-with-Class"><span class="nav-number">3.13.</span> <span class="nav-text">以类取代类型码 Replace Type Code with Class</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#以子类取代类型码-Replace-Type-Code-with-Subclasses"><span class="nav-number">3.14.</span> <span class="nav-text">以子类取代类型码 Replace Type Code with Subclasses</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#以-State-Strategy-取代类型码-Replace-Type-Code-with-State-Strategy"><span class="nav-number">3.15.</span> <span class="nav-text">以 State/Strategy 取代类型码 Replace Type Code with State/Strategy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#以字段取代子类-Replace-Subclass-with-Fields"><span class="nav-number">3.16.</span> <span class="nav-text">以字段取代子类 Replace Subclass with Fields</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简化条件表达式"><span class="nav-number">4.</span> <span class="nav-text">简化条件表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分解条件表达式-Decompose-Conditional"><span class="nav-number">4.1.</span> <span class="nav-text">分解条件表达式 Decompose Conditional</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#合并条件表达式-Consolidate-Conditional-Expression"><span class="nav-number">4.2.</span> <span class="nav-text">合并条件表达式 Consolidate Conditional Expression</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#合并重复的条件片段-Consolidate-Duplicate-Conditional-Fragments"><span class="nav-number">4.3.</span> <span class="nav-text">合并重复的条件片段 Consolidate Duplicate Conditional Fragments</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#移除控制标记-Remove-Control-Flag"><span class="nav-number">4.4.</span> <span class="nav-text">移除控制标记 Remove Control Flag</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#以-Guard-语句取代嵌套条件表达式-Replace-Nested-Conditional-with-Guard-Clauses"><span class="nav-number">4.5.</span> <span class="nav-text">以 Guard 语句取代嵌套条件表达式 Replace Nested Conditional with Guard Clauses</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#以多态取代条件表达式-Replace-Conditional-with-Polymorphism"><span class="nav-number">4.6.</span> <span class="nav-text">以多态取代条件表达式 Replace Conditional with Polymorphism</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#引入-Null-对象"><span class="nav-number">4.7.</span> <span class="nav-text">引入 Null 对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#引入断言-Introduce-Assertion"><span class="nav-number">4.8.</span> <span class="nav-text">引入断言 Introduce Assertion</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Li Xuefeng</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a></div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"your-duoshuo-shortname，待添加"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  


















  





  

  

  

  
  

  

  

  

</body>
</html>
