[{"title":"学习计划(2017/4/15)","date":"2017-04-15T11:15:25.000Z","path":"2017/04/15/学习计划-2017-4-15/","text":"最近想来，前些日子浪费了不少时间，因此写下此计划，用来提醒自己接下来的工作重点： Flink的学习，重点学习flink的相关api和一些常见的开发方法，闲暇时间阅读下微信的flink公众号的内容； es的学习，作为目前流行的外网搜索引擎，一个搜索人应该要掌握的基本知识； ha3的学习，快速搭建一个搜索引擎； highcharts和anjularJs的学习，最近开发前端的页面需要补充这部分的知识。","tags":[]},{"title":"Hexo相关的使用方式——第一篇文章","date":"2017-03-19T11:13:59.000Z","path":"2017/03/19/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"Hello","slug":"Hello","permalink":"http://yoursite.com/tags/Hello/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"搜索——ElasticSearch的学习笔记","date":"2017-03-16T03:59:31.000Z","path":"2017/03/16/搜索之es的学习/","text":"一、ElasticSearch使用简介最近在学习ElasticSearch的相关知识点，已经完整的阅读了ElasticSearch权威指南这本书，为了学有所获，现在将自己的学习笔记整理如下，仅供大家参考。我将从如下几个方面来向大家介绍。 ElasticSearch 5.2.2的安装使用； ElasticSearch 5.2.2的基础概念； ElasticSearch 5.2.2的简单查询； ElasticSearch 5.2.2的配置相关； ElasticSearch 5.2.2的基本操作。 ElasticSearch是一个实时分布式搜索和分析引擎。它让你以前所未有的速度处理大数据成为可能。它用于全文搜索、结构化搜索、分析以及将这三者混合使用。ElasticSearch是一个基于Apache Lucene（TM）的开源搜索引擎。无论是在开源还是专有领域，Lucene可以被认为是迄今为止最先进、性能最好、功能最全的搜索引擎库。ElasticSearch也是用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful Api来隐藏Lucene的复杂性，从而让全文搜索变得简单。 二、ElasticSearch 5.2.2的安装使用： 安装ElasticSearch 安装ElasticSearch唯一的要求是安装官方新版的Java，地址：www.java.com;你可以从 elasticsearch.org/download 下载最新版本的ElasticSearch。 123curl -L -O http://download.elasticsearch.org/PATH/TO/VERSION.zip &lt;1&gt; unzip elasticsearch-$VERSION.zipcd elasticsearch-$VERSION 运行ElasticSearch ElasticSearch已经准备就绪，执行以下命令可在前台启动： 1./bin/elasticsearch 如果想在后台以守护进程模式运行，添加-d参数。 打开另一个终端进行测试： 1curl &apos;http://localhost:9200/?pretty&apos; 你能看到如下返回信息： 当你看到上图中的信息之后，说明你的ElasticSearch集群已经启动并且正常运行，接下来我们可以开始各种实验了。 三、ElasticSearch 5.2.2的基础概念：本节是ElasticSearch5.2.2的基础概念部分的介绍，主要介绍集群，节点，索引，类型，文档，分片，副本等基础概念。 基本概念：简单的介绍下，详细的见Basic Concepts 集群（cluster）：集群由一个或者多个节点组成，由名称唯一标识； 节点（node）：一个单独的ElasticSearch实例； 索引（index）：文档的集合； 类型（type）：索引的逻辑分类/分区； 文档（document）：能够被索引的信息基础单元； 分片（shard）：索引的物理分区，是一个最小的Lucene索引单元。分为primary shard（主分片）和replica shard（简称replicas）。 副本/备份（replicas）:主分片的备份。 类比关系数据库其中索引、类型、文档的概念可以类比关系型数据库 ElasticSearch 关系型数据库 索引（index） 数据库（database） 类型（type） 表（table） 文档（document） 行记录（row） 字段（field） 列（column） 四、ElasticSearch 5.2.2的简单查询：请求体查询简单查询语句（lite）是一种有效的命令行adhoc查询。但是，如果你想要善用搜索，你必须使用请求体查询（request body search）API。之所以这么称呼，是因为大多数的参数以Json格式所容纳而非查询字符串。本节主要介绍如何使用Elasticsearch进行简单的查询，查询方式分为如下两种方式。 通过REST request URI发送查询参数； 通过REST request body发送查询参数。 首先看一个空查询。 12GET /_search&#123;&#125; 这是一个空查询语句，空查询将会返回索引中所有的文档，同字符串查询一样，你可以查询一个，多个或_all索引（indices）或类型（types）： 12345GET /_search&#123; &quot;from&quot;:30, &quot;size&quot;:10&#125; 因为携带交互数据的GET请求并不被广泛支持，所以search API同样支持POST请求，需要注意一点，Elasticsearch和sql的区别，Es一旦获得了结果，Es就彻底完成了请求，且不保存任何服务端资源或者状态信息，这和SQL里一些得到结果子集再通过状态信息（如游标）得到剩下结果集的情况不同。 Query DSL结构化查询是一种灵活的，多表现形式的查询语言。Elasticsearch在一个简单的JSON接口中用结构化查询来展现Lucene绝大多数的能力。它使得你的查询更加灵活，精准，易于阅读并且易于debug。使用结构化查询，你需要传递query参数：1234GET /_search&#123; &quot;query&quot;: YOUR_QUERY_HERE&#125; 空查询 -{} - 功能上等同于使用match_all查询子句，正如其名字一样，匹配所有的文档： 123456GET /_search&#123; &quot;query&quot;:&#123; &quot;match_all&quot;:&#123;&#125; &#125;&#125; 更多的例子，如must，should，bool query等等。 过滤器查询条件与文档的相关性用_score这个数值字段来表示，数值越高代表越相关。而有时我们不需要去计算相关性，只需要确定文档满不满足查询条件即可，这时可用filter（过滤器） 1234567891011121314151617# uses a bool query to return all accounts with balances between 20000 and 30000GET /bank/_search&#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;must&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;filter&quot;: &#123; &quot;range&quot;: &#123; &quot;balance&quot;: &#123; &quot;gte&quot;: 20000, &quot;lte&quot;: 30000 &#125; &#125; &#125; &#125; &#125;&#125; 在网上的这个例子中，返回balance在20000~30000的文档，所有满足条件的文档的匹配程度都是”等价”的，没有谁更相关，所以计算分数是毫无意义的。 聚合aggregation（聚合）能够对数据分组和提取统计信息，大致类似SQL中的group by和聚合函数。Elasticsearch能同时分别返回查询结果和聚合结果，从而避免多次查询。 12345678910111213# 类似SQL中的 SELECT state, COUNT(*) FROM bank GROUP BY state ORDER BY COUNT(*) DESCGET /bank/_search&#123; &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;group_by_state&quot;: &#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;state.keyword&quot; &#125; &#125; &#125;&#125; 五、ElasticSearch 5.2.2的配置相关：为什么有 Bootstrap ChecksBootstrap Checks 是 Elasticsearch 5.0 新加入的，在之前的 2.x 版本是没有的。之前的版本中，错误的配置会被当成 warning 记录到日志中，但这些信息往往被用户忽视。为了保证一些重要的配置得到应有的重视，Elasticsearch 会在启动时进行 Bootstrap Checks . Bootstrap Checks 会检查很多 Elasticsearch 和系统的配置。在开发模式下，所有没通过的检查都会报 warnings 并写进日志文件，即使检查没通过，依然可以启动节点运行 Elasticsearch；而在生产模式下，任何没通过的 Bootstrap Checks 都会报异常并阻止 Elasticsearch 启动。 开发模式 vs 生产模式Elasticsearch 的 HTTP 默认绑定到localhost，并且 transport 使用内部通信，适用于日常开发；而组成集群时，由于每个 ES 实例要可达，故 transport 必须绑定到外部接口。 一般 Elasticsearch 默认你是在开发模式下工作；一旦配置了诸如network.host的网络配置项，Elasticsearch会认为你处于生产环境。这是避免服务器因不良配置造成数据丢失的重要安全措施。 另外，HTTP 和 transport 可以分别通过 http.host 和 transport.host进行配置，所以配置单点实例可达时，可以用 HTTP 进行测试而无需触发生产模式。 Bootstrap Checks有很多检查项，以 Heap size check为例子，由于 Elasticsearch 是使用 Java 写的，程序在 JVM 上运行，而 JVM 的堆大小是可以配置的。如果 JVM 的起始堆大小不等于最大堆大小，那么在堆 resize 的时候很容易造成系统停滞，为了避免这种resize pauses,一开始就应将两者设置成相等。 类似的检查还有很多，大部分是针对 JVM 配置项的检查，有些检查项只在 Linux 系统上会检查，有些在所有平台都会检查。这里只列举出检查项，不作进一步说明了。 Heap size check File descriptor check Memory lock check Maximum number of threads check Maximum size virtual memory check Maximum map count check Client JVM check Use serial collector check OnError and OnOutOfMemoryError checks 重要的系统配置从上节可知，很多Bootstrap Checks涉及到系统配置，我们需要对系统进行一些配置来使 Elasticsearch 可以获取更多的资源。 一般必须配置以下几条设置： Set JVM heap size Disable swapping Increase sufficient virtual memory Ensure sufficient threads 在哪里配置系统设置取决于你使用的安装包以及你使用的操作系统。JVM配置参数建议通过 jvm.options 配置文件进行配置，当然，也可以通过ES_JAVA_OPTS环境变量来配置。 六、ElasticSearch 5.2.2的基本操作：基础指令下面是在Console 中输入的一些命令，可以依次运行看看结果。 1234567891011121314151617181920212223# Cluster HealthGET _cat/health?v# list of nodesGET /_cat/nodes?v# List All IndicesGET /_cat/indices?v# Create an IndexPUT /customer?prettyGET /_cat/indices?v# Index and Query a DocumentPUT /customer/external/1?pretty&#123; &quot;name&quot;:&quot;John Doe&quot;&#125;GET /customer/external/1?prettyDELETE /customer/external/1# Delete an Index DELETE /customer?pretty 可以看出Elasticsearch的REST API基本格式： 1&lt;REST Verb&gt; /&lt;Index&gt;/&lt;Type&gt;/&lt;ID&gt; 索引/替换文档1234567891011# Indexing/Replacing DocumentsPUT /customer/external/1?pretty&#123; &quot;name&quot;: &quot;John Doe&quot;&#125;# using the POST verb instead of PUT since we didn’t specify an IDPOST /customer/external?pretty&#123; &quot;name&quot;: &quot;Jane Doe&quot;&#125; 使用PUT方法需要明确指定ID，两次PUT的id相同则是替换之前的文档，第二次id不同则是创建新的文档 没明确指定ID则使用POST方法 更新文档12345678910111213141516# Updating DocumentsPOST /customer/external/1/_update?pretty&#123; &quot;doc&quot;: &#123; &quot;name&quot;: &quot;Jane Doe&quot; &#125;&#125;POST /customer/external/1/_update?pretty&#123; &quot;doc&quot;: &#123; &quot;name&quot;: &quot;Jane Doe&quot;, &quot;age&quot;: 20 &#125;&#125;# uses a script to increment the age by 5POST /customer/external/1/_update?pretty&#123; &quot;script&quot; : &quot;ctx._source.age += 5&quot;&#125; 更新文档其实就是先删除再新建一个新的文档 1Whenever we do an update, Elasticsearch deletes the old document and then indexes a new document with the update applied to it in one shot 删除文档12# Deleting DocumentsDELETE /customer/external/2?pretty 直接删除整个index要比删除index里的所有文档更有效率 1It is worth noting that it is much more efficient to delete a whole index instead of deleting all documents with the Delete By Query API. 批处理123456789101112# Batch Processing POST /customer/external/_bulk?pretty&#123;&quot;index&quot;:&#123;&quot;_id&quot;:&quot;1&quot;&#125;&#125;&#123;&quot;name&quot;: &quot;John Doe&quot; &#125;&#123;&quot;index&quot;:&#123;&quot;_id&quot;:&quot;2&quot;&#125;&#125;&#123;&quot;name&quot;: &quot;Jane Doe&quot; &#125;POST /customer/external/_bulk?pretty&#123;&quot;update&quot;:&#123;&quot;_id&quot;:&quot;1&quot;&#125;&#125;&#123;&quot;doc&quot;: &#123; &quot;name&quot;: &quot;John Doe becomes Jane Doe&quot; &#125; &#125;&#123;&quot;delete&quot;:&#123;&quot;_id&quot;:&quot;2&quot;&#125;&#125; 删除操作后面没有相应的文档数据，只提供要删除的 ID 即可； 批处理对每个操作(action)按顺序依次执行(sequentially and in order)，如果单个操作出错，也会继续执行剩下的操作； 批处理返回结果时，按照请求顺序为每个操作提供一个状态以便用户检查。","tags":[]},{"title":"vue.js以及highcharts.js的深入学习(待补充)","date":"2017-03-16T03:59:10.000Z","path":"2017/03/16/vue-js以及highcharts-js的深入学习/","text":"","tags":[]},{"title":"Sun的jdk命令行工具","date":"2017-03-16T03:58:43.000Z","path":"2017/03/16/jvm的jdk命令行工具和java多线程相关知识点学习/","text":"名称 主要作用 jps JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程 jstat JVM Statistics Monitoring Tool,用于收集Hotspot虚拟机各方面的运行数据 jinfo Configuration Info for Java,显示虚拟机配置信息 jmap Memory Map for Java,生成虚拟机的内存转储快照（heapdump文件） jhat JVM Heap Dump Browser，用于分析heapdump文件，它会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果 jstack Stack Trace for Java,显示虚拟机的线程快照","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Jvm","slug":"Jvm","permalink":"http://yoursite.com/tags/Jvm/"}]},{"title":"ha3 3.0(待补充)","date":"2017-03-16T03:57:58.000Z","path":"2017/03/16/ha3-3-0/","text":"","tags":[]},{"title":"成长集<<电子书一期>>(待补充)","date":"2017-03-16T03:55:41.000Z","path":"2017/03/16/成长集-电子书一期/","text":"","tags":[]},{"title":"java多线程体系(待补充)","date":"2017-03-16T03:54:57.000Z","path":"2017/03/16/java多线程体系/","text":"","tags":[]},{"title":"机器学习扫盲(待补充)","date":"2017-03-16T03:50:29.000Z","path":"2017/03/16/机器学习扫盲/","text":"","tags":[]}]